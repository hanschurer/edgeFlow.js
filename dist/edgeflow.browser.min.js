var He=Object.defineProperty;var Ke=(r,e,t)=>e in r?He(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var l=(r,e,t)=>(Ke(r,typeof e!="symbol"?e+"":e,t),t);var p=class extends Error{constructor(t,s,n){super(t);l(this,"code");l(this,"details");this.code=s,this.details=n,this.name="EdgeFlowError"}},m={RUNTIME_NOT_AVAILABLE:"RUNTIME_NOT_AVAILABLE",RUNTIME_INIT_FAILED:"RUNTIME_INIT_FAILED",RUNTIME_NOT_INITIALIZED:"RUNTIME_NOT_INITIALIZED",MODEL_NOT_FOUND:"MODEL_NOT_FOUND",MODEL_LOAD_FAILED:"MODEL_LOAD_FAILED",MODEL_INVALID_FORMAT:"MODEL_INVALID_FORMAT",MODEL_NOT_LOADED:"MODEL_NOT_LOADED",INFERENCE_FAILED:"INFERENCE_FAILED",INFERENCE_TIMEOUT:"INFERENCE_TIMEOUT",INFERENCE_CANCELLED:"INFERENCE_CANCELLED",OUT_OF_MEMORY:"OUT_OF_MEMORY",MEMORY_LEAK_DETECTED:"MEMORY_LEAK_DETECTED",TENSOR_SHAPE_MISMATCH:"TENSOR_SHAPE_MISMATCH",TENSOR_DTYPE_MISMATCH:"TENSOR_DTYPE_MISMATCH",TENSOR_DISPOSED:"TENSOR_DISPOSED",PIPELINE_NOT_SUPPORTED:"PIPELINE_NOT_SUPPORTED",PIPELINE_INPUT_INVALID:"PIPELINE_INPUT_INVALID",INVALID_ARGUMENT:"INVALID_ARGUMENT",NOT_IMPLEMENTED:"NOT_IMPLEMENTED",UNKNOWN_ERROR:"UNKNOWN_ERROR"};var Xe=0;function Ye(){return`tensor_${++Xe}_${Date.now().toString(36)}`}function ne(r){switch(r){case"float32":return Float32Array;case"float16":return Float32Array;case"int32":return Int32Array;case"int64":return BigInt64Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;default:throw new p(`Unsupported data type: ${r}`,m.INVALID_ARGUMENT,{dtype:r})}}function P(r){return r.length===0?1:r.reduce((e,t)=>e*t,1)}function Je(r){for(let e=0;e<r.length;e++){let t=r[e];if(t===void 0||!Number.isInteger(t)||t<0)throw new p(`Invalid shape dimension at index ${e}: ${t}`,m.INVALID_ARGUMENT,{shape:r,index:e,dimension:t})}}var g=class r{constructor(e,t,s="float32"){l(this,"id");l(this,"dtype");l(this,"shape");l(this,"size");l(this,"_data");l(this,"_isDisposed",!1);Je(t),this.id=Ye(),this.dtype=s,this.shape=Object.freeze([...t]),this.size=P(this.shape);let n=this.size;if(e.length!==n)throw new p(`Data length (${e.length}) does not match shape ${JSON.stringify(t)} (expected ${n})`,m.TENSOR_SHAPE_MISMATCH,{dataLength:e.length,expectedSize:n,shape:t});if(e instanceof Array){let o=ne(s);if(this._data=new o(e.length),s==="int64"){let i=this._data;for(let a=0;a<e.length;a++)i[a]=BigInt(Math.round(e[a]??0))}else for(let i=0;i<e.length;i++)this._data[i]=e[i]??0}else this._data=e}get data(){return this.checkDisposed(),this._data}get isDisposed(){return this._isDisposed}checkDisposed(){if(this._isDisposed)throw new p("Cannot access disposed tensor",m.TENSOR_DISPOSED,{tensorId:this.id})}toFloat32Array(){if(this.checkDisposed(),this._data instanceof Float32Array)return this._data;let e=new Float32Array(this.size);for(let t=0;t<this.size;t++)e[t]=Number(this._data[t]??0);return e}toArray(){if(this.checkDisposed(),this.dtype==="int64"){let e=this._data,t=[];for(let s=0;s<e.length;s++)t.push(Number(e[s]));return t}return Array.from(this._data)}clone(){this.checkDisposed();let e=this._data.constructor,t=new e(this._data);return new r(t,this.shape,this.dtype)}dispose(){this._isDisposed||(this._isDisposed=!0,Object.assign(this,{_data:null}))}get(...e){if(this.checkDisposed(),e.length!==this.shape.length)throw new p(`Expected ${this.shape.length} indices, got ${e.length}`,m.INVALID_ARGUMENT,{expectedIndices:this.shape.length,gotIndices:e.length});let t=0,s=1;for(let n=this.shape.length-1;n>=0;n--){let o=e[n]??0,i=this.shape[n]??1;if(o<0||o>=i)throw new p(`Index ${o} out of bounds for dimension ${n} with size ${i}`,m.INVALID_ARGUMENT,{index:o,dimension:n,size:i});t+=o*s,s*=i}return Number(this._data[t]??0)}set(e,...t){if(this.checkDisposed(),t.length!==this.shape.length)throw new p(`Expected ${this.shape.length} indices, got ${t.length}`,m.INVALID_ARGUMENT,{expectedIndices:this.shape.length,gotIndices:t.length});let s=0,n=1;for(let o=this.shape.length-1;o>=0;o--){let i=t[o]??0,a=this.shape[o]??1;if(i<0||i>=a)throw new p(`Index ${i} out of bounds for dimension ${o} with size ${a}`,m.INVALID_ARGUMENT,{index:i,dimension:o,size:a});s+=i*n,n*=a}this._data[s]=e}reshape(e){this.checkDisposed();let t=P(e);if(t!==this.size)throw new p(`Cannot reshape tensor of size ${this.size} to shape ${JSON.stringify(e)} (size ${t})`,m.TENSOR_SHAPE_MISMATCH,{currentSize:this.size,newSize:t,newShape:e});let s=this._data.constructor,n=new s(this._data);return new r(n,e,this.dtype)}transpose(){if(this.checkDisposed(),this.shape.length!==2)throw new p("Transpose is currently only supported for 2D tensors",m.NOT_IMPLEMENTED,{shape:this.shape});let[e,t]=this.shape,s=new Float32Array(this.size);for(let n=0;n<e;n++)for(let o=0;o<t;o++)s[o*e+n]=Number(this._data[n*t+o]??0);return new r(s,[t,e],this.dtype)}toString(){return`Tensor(shape=[${this.shape.join(", ")}], dtype=${this.dtype})`}};function Qe(r,e,t="float32"){if(Array.isArray(r)&&r.length>0&&Array.isArray(r[0])){let n=r.length,o=r[0].length,i=[];for(let a of r){if(a.length!==o)throw new p("Nested arrays must have consistent dimensions",m.INVALID_ARGUMENT);i.push(...a)}return new g(i,e??[n,o],t)}let s=e??[r.length];return new g(r,s,t)}function Se(r,e="float32"){let t=P(r),s=ne(e),n=new s(t);return new g(n,r,e)}function Ze(r,e="float32"){let t=P(r),s=ne(e),n=new s(t);return n.fill(1),new g(n,r,e)}function et(r,e,t="float32"){let s=P(r),n=ne(t),o=new n(s);return o.fill(e),new g(o,r,t)}function tt(r,e="float32"){let t=P(r),s=new Float32Array(t);for(let n=0;n<t;n++)s[n]=Math.random();return new g(s,r,e)}function st(r,e="float32"){let t=P(r),s=new Float32Array(t);for(let n=0;n<t;n+=2){let o=Math.random(),i=Math.random(),a=Math.sqrt(-2*Math.log(o)),c=2*Math.PI*i;s[n]=a*Math.cos(c),n+1<t&&(s[n+1]=a*Math.sin(c))}return new g(s,r,e)}function nt(r,e,t=1,s="float32"){e===void 0&&(e=r,r=0);let n=Math.ceil((e-r)/t),o=new Float32Array(n);for(let i=0;i<n;i++)o[i]=r+i*t;return new g(o,[n],s)}function rt(r,e,t=50,s="float32"){let n=new Float32Array(t),o=(e-r)/(t-1);for(let i=0;i<t;i++)n[i]=r+i*o;return new g(n,[t],s)}function it(r,e="float32"){let t=new Float32Array(r*r);for(let s=0;s<r;s++)t[s*r+s]=1;return new g(t,[r,r],e)}function ot(r,e){if(typeof e=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)+e;return new g(o,r.shape,r.dtype)}if(r.size!==e.size)throw new p("Tensor sizes must match for element-wise operations",m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let t=new Float32Array(r.size),s=r.toFloat32Array(),n=e.toFloat32Array();for(let o=0;o<r.size;o++)t[o]=(s[o]??0)+(n[o]??0);return new g(t,r.shape,r.dtype)}function at(r,e){if(typeof e=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)-e;return new g(o,r.shape,r.dtype)}if(r.size!==e.size)throw new p("Tensor sizes must match for element-wise operations",m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let t=new Float32Array(r.size),s=r.toFloat32Array(),n=e.toFloat32Array();for(let o=0;o<r.size;o++)t[o]=(s[o]??0)-(n[o]??0);return new g(t,r.shape,r.dtype)}function ct(r,e){if(typeof e=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)*e;return new g(o,r.shape,r.dtype)}if(r.size!==e.size)throw new p("Tensor sizes must match for element-wise operations",m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let t=new Float32Array(r.size),s=r.toFloat32Array(),n=e.toFloat32Array();for(let o=0;o<r.size;o++)t[o]=(s[o]??0)*(n[o]??0);return new g(t,r.shape,r.dtype)}function be(r,e){if(typeof e=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)/e;return new g(o,r.shape,r.dtype)}if(r.size!==e.size)throw new p("Tensor sizes must match for element-wise operations",m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let t=new Float32Array(r.size),s=r.toFloat32Array(),n=e.toFloat32Array();for(let o=0;o<r.size;o++)t[o]=(s[o]??0)/(n[o]??0);return new g(t,r.shape,r.dtype)}function lt(r,e){if(r.shape.length!==2||e.shape.length!==2)throw new p("matmul requires 2D tensors",m.INVALID_ARGUMENT,{aShape:r.shape,bShape:e.shape});let[t,s]=r.shape,[n,o]=e.shape;if(s!==n)throw new p(`Matrix dimensions incompatible for multiplication: (${t}x${s}) @ (${n}x${o})`,m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let i=new Float32Array(t*o),a=r.toFloat32Array(),c=e.toFloat32Array();for(let h=0;h<t;h++)for(let u=0;u<o;u++){let f=0;for(let d=0;d<s;d++)f+=(a[h*s+d]??0)*(c[d*o+u]??0);i[h*o+u]=f}return new g(i,[t,o],r.dtype)}function O(r,e=-1){let t=r.toFloat32Array(),s=new Float32Array(r.size),n=e<0?r.shape.length+e:e;if(n<0||n>=r.shape.length)throw new p(`Invalid axis ${e} for tensor with ${r.shape.length} dimensions`,m.INVALID_ARGUMENT,{axis:e,shape:r.shape});if(r.shape.length===1){let o=-1/0;for(let a=0;a<r.size;a++)(t[a]??0)>o&&(o=t[a]??0);let i=0;for(let a=0;a<r.size;a++)s[a]=Math.exp((t[a]??0)-o),i+=s[a]??0;for(let a=0;a<r.size;a++)s[a]=(s[a]??0)/i;return new g(s,r.shape,r.dtype)}if(r.shape.length===2&&n===1){let[o,i]=r.shape;for(let a=0;a<o;a++){let c=-1/0;for(let u=0;u<i;u++)(t[a*i+u]??0)>c&&(c=t[a*i+u]??0);let h=0;for(let u=0;u<i;u++)s[a*i+u]=Math.exp((t[a*i+u]??0)-c),h+=s[a*i+u]??0;for(let u=0;u<i;u++)s[a*i+u]=(s[a*i+u]??0)/h}return new g(s,r.shape,r.dtype)}throw new p("Softmax currently only supports 1D tensors or 2D tensors along the last axis",m.NOT_IMPLEMENTED,{shape:r.shape,axis:e})}function me(r){let e=r.toFloat32Array(),t=new Float32Array(r.size);for(let s=0;s<r.size;s++)t[s]=Math.max(0,e[s]??0);return new g(t,r.shape,r.dtype)}function ge(r){let e=r.toFloat32Array(),t=new Float32Array(r.size);for(let s=0;s<r.size;s++)t[s]=1/(1+Math.exp(-(e[s]??0)));return new g(t,r.shape,r.dtype)}function ut(r){let e=r.toFloat32Array(),t=new Float32Array(r.size);for(let s=0;s<r.size;s++)t[s]=Math.tanh(e[s]??0);return new g(t,r.shape,r.dtype)}function pe(r,e){let t=r.toFloat32Array();if(e===void 0){let o=0;for(let i=0;i<r.size;i++)o+=t[i]??0;return o}let s=e<0?r.shape.length+e:e;if(s<0||s>=r.shape.length)throw new p(`Invalid axis ${e} for tensor with ${r.shape.length} dimensions`,m.INVALID_ARGUMENT,{axis:e,shape:r.shape});let n=[...r.shape];if(n.splice(s,1),n.length===0){let o=0;for(let i=0;i<r.size;i++)o+=t[i]??0;return o}if(r.shape.length===2){let[o,i]=r.shape;if(s===0){let a=new Float32Array(i);for(let c=0;c<i;c++)for(let h=0;h<o;h++)a[c]=(a[c]??0)+(t[h*i+c]??0);return new g(a,[i],r.dtype)}else{let a=new Float32Array(o);for(let c=0;c<o;c++)for(let h=0;h<i;h++)a[c]=(a[c]??0)+(t[c*i+h]??0);return new g(a,[o],r.dtype)}}throw new p("Sum along axis currently only supports up to 2D tensors",m.NOT_IMPLEMENTED,{shape:r.shape,axis:e})}function ht(r,e){if(e===void 0)return pe(r)/r.size;let t=pe(r,e);if(typeof t=="number")return t/(r.shape[e]??1);let s=r.shape[e]??1;return be(t,s)}function dt(r,e){let t=r.toFloat32Array();if(e===void 0){let n=0,o=t[0]??-1/0;for(let i=1;i<r.size;i++)(t[i]??-1/0)>o&&(o=t[i]??-1/0,n=i);return n}let s=e<0?r.shape.length+e:e;if(r.shape.length===2&&s===1){let[n,o]=r.shape,i=new Float32Array(n);for(let a=0;a<n;a++){let c=0,h=t[a*o]??-1/0;for(let u=1;u<o;u++)(t[a*o+u]??-1/0)>h&&(h=t[a*o+u]??-1/0,c=u);i[a]=c}return new g(i,[n],"int32")}throw new p("Argmax along axis currently only supports 2D tensors along the last axis",m.NOT_IMPLEMENTED,{shape:r.shape,axis:e})}function ft(r,e=0){if(r.length===0)throw new p("Cannot concatenate empty array of tensors",m.INVALID_ARGUMENT);if(r.length===1)return r[0]?.clone()??Se([0]);let t=r[0];if(!t)throw new p("First tensor is undefined",m.INVALID_ARGUMENT);let s=e<0?t.shape.length+e:e;for(let i=1;i<r.length;i++){let a=r[i];if(a){if(a.shape.length!==t.shape.length)throw new p("All tensors must have the same number of dimensions",m.TENSOR_SHAPE_MISMATCH);for(let c=0;c<t.shape.length;c++)if(c!==s&&t.shape[c]!==a.shape[c])throw new p(`Shape mismatch at dimension ${c}`,m.TENSOR_SHAPE_MISMATCH)}}let n=[...t.shape],o=0;for(let i of r)i&&(o+=i.shape[s]??0);if(n[s]=o,t.shape.length===1){let i=new Float32Array(o),a=0;for(let c of r)c&&(i.set(c.toFloat32Array(),a),a+=c.size);return new g(i,n,t.dtype)}throw new p("Concatenation currently only supports 1D tensors",m.NOT_IMPLEMENTED)}var we=class{constructor(e,t,s,n){l(this,"id");l(this,"modelId");l(this,"priority");l(this,"createdAt");l(this,"_status","pending");l(this,"_startedAt");l(this,"_completedAt");l(this,"_result");l(this,"_error");l(this,"_executor");l(this,"_resolvers",[]);l(this,"_cancelled",!1);this.id=e,this.modelId=t,this.priority=s,this.createdAt=Date.now(),this._executor=n}get status(){return this._status}get startedAt(){return this._startedAt}get completedAt(){return this._completedAt}get result(){return this._result}get error(){return this._error}cancel(){if(this._status==="pending"){this._cancelled=!0,this._status="cancelled",this._completedAt=Date.now();let e=new p("Task was cancelled",m.INFERENCE_CANCELLED,{taskId:this.id});for(let{reject:t}of this._resolvers)t(e);this._resolvers=[]}}wait(){return this._status==="completed"?Promise.resolve(this._result):this._status==="failed"?Promise.reject(this._error):this._status==="cancelled"?Promise.reject(new p("Task was cancelled",m.INFERENCE_CANCELLED,{taskId:this.id})):new Promise((e,t)=>{this._resolvers.push({resolve:e,reject:t})})}async execute(){if(!this._cancelled){this._status="running",this._startedAt=Date.now();try{this._result=await this._executor(),this._status="completed",this._completedAt=Date.now();for(let{resolve:e}of this._resolvers)e(this._result)}catch(e){this._error=e instanceof Error?e:new Error(String(e)),this._status="failed",this._completedAt=Date.now();for(let{reject:t}of this._resolvers)t(this._error)}this._resolvers=[]}}},ze={critical:0,high:1,normal:2,low:3},ye=class{constructor(){l(this,"items",[])}get length(){return this.items.length}isEmpty(){return this.items.length===0}enqueue(e){let t=!1;for(let s=0;s<this.items.length;s++){let n=this.items[s];if(n&&ze[e.priority]<ze[n.priority]){this.items.splice(s,0,e),t=!0;break}}t||this.items.push(e)}dequeue(){return this.items.shift()}peek(){return this.items[0]}remove(e){let t=this.items.findIndex(s=>s.id===e);if(t!==-1){let[s]=this.items.splice(t,1);return s}}getAll(){return[...this.items]}clear(){this.items=[]}};var pt=0;function mt(){return`task_${++pt}_${Date.now().toString(36)}`}var gt={maxConcurrentTasks:4,maxConcurrentPerModel:1,defaultTimeout:3e4,enableBatching:!1,maxBatchSize:32,batchTimeout:50},V=class{constructor(e={}){l(this,"options");l(this,"queues",new Map);l(this,"runningTasks",new Map);l(this,"allTasks",new Map);l(this,"batchers",new Map);l(this,"listeners",new Map);l(this,"globalRunningCount",0);l(this,"isProcessing",!1);l(this,"disposed",!1);this.options={...gt,...e}}getQueue(e){let t=this.queues.get(e);return t||(t=new ye,this.queues.set(e,t)),t}getRunningSet(e){let t=this.runningTasks.get(e);return t||(t=new Set,this.runningTasks.set(e,t)),t}canStartTask(e){if(this.globalRunningCount>=this.options.maxConcurrentTasks)return!1;let t=this.runningTasks.get(e);return!(t&&t.size>=this.options.maxConcurrentPerModel)}async processQueue(){if(this.isProcessing||this.disposed)return;this.isProcessing=!0;try{let t=[];for(let[s,n]of this.queues)for(;!n.isEmpty()&&this.canStartTask(s);){let o=n.dequeue();o&&o.status==="pending"&&(t.push(o),this.getRunningSet(s).add(o.id),this.globalRunningCount++)}await Promise.all(t.map(async s=>{this.emit("inference:start",{taskId:s.id,modelId:s.modelId});try{await s.execute(),this.emit("inference:complete",{taskId:s.id,modelId:s.modelId,duration:(s.completedAt??0)-(s.startedAt??0)})}catch(n){this.emit("inference:error",{taskId:s.id,modelId:s.modelId,error:n})}finally{let n=this.runningTasks.get(s.modelId);n&&n.delete(s.id),this.globalRunningCount--}}))}finally{this.isProcessing=!1}let e=!1;for(let t of this.queues.values())if(!t.isEmpty()){e=!0;break}e&&setTimeout(()=>this.processQueue(),0)}schedule(e,t,s="normal"){if(this.disposed)throw new p("Scheduler has been disposed",m.RUNTIME_NOT_INITIALIZED);let n=new we(mt(),e,s,t);return this.allTasks.set(n.id,n),this.getQueue(e).enqueue(n),this.processQueue(),n}scheduleWithTimeout(e,t,s=this.options.defaultTimeout,n="normal"){let o=()=>new Promise((i,a)=>{let c=setTimeout(()=>{a(new p(`Task timed out after ${s}ms`,m.INFERENCE_TIMEOUT,{timeout:s}))},s);t().then(h=>{clearTimeout(c),i(h)}).catch(h=>{clearTimeout(c),a(h)})});return this.schedule(e,o,n)}async scheduleAll(e){let t=e.map(({modelId:s,executor:n,priority:o})=>this.schedule(s,n,o));return Promise.all(t.map(s=>s.wait()))}getTask(e){return this.allTasks.get(e)}cancelTask(e){let t=this.allTasks.get(e);if(t&&t.status==="pending"){t.cancel();for(let s of this.queues.values())s.remove(e);return!0}return!1}cancelAllForModel(e){let t=this.queues.get(e);if(!t)return 0;let s=0;for(let n of t.getAll())n.status==="pending"&&(n.cancel(),s++);return t.clear(),s}getStats(){let e={totalTasks:this.allTasks.size,pendingTasks:0,runningTasks:0,completedTasks:0,failedTasks:0,cancelledTasks:0,queuedByModel:{}};for(let t of this.allTasks.values())switch(t.status){case"pending":e.pendingTasks++;break;case"running":e.runningTasks++;break;case"completed":e.completedTasks++;break;case"failed":e.failedTasks++;break;case"cancelled":e.cancelledTasks++;break}for(let[t,s]of this.queues)e.queuedByModel[t]=s.length;return e}on(e,t){let s=this.listeners.get(e);s||(s=new Set,this.listeners.set(e,s)),s.add(t)}off(e,t){let s=this.listeners.get(e);s&&s.delete(t)}emit(e,t){let s={type:e,timestamp:Date.now(),data:t},n=this.listeners.get(e);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}clearHistory(){for(let[e,t]of this.allTasks)(t.status==="completed"||t.status==="failed"||t.status==="cancelled")&&this.allTasks.delete(e)}dispose(){this.disposed=!0;for(let e of this.queues.values()){for(let t of e.getAll())t.cancel();e.clear()}for(let e of this.batchers.values())e.clear();this.queues.clear(),this.runningTasks.clear(),this.allTasks.clear(),this.batchers.clear(),this.listeners.clear()}},U=null;function re(){return U||(U=new V),U}function ke(r){U&&U.dispose(),U=r}function wt(r){ke(new V(r))}var yt={initialSize:67108864,maxSize:536870912,growthFactor:1.5,autoGC:!0,gcThreshold:.8},I=class I{constructor(e={}){l(this,"config");l(this,"resources",new Map);l(this,"disposers",new Map);l(this,"listeners",new Map);l(this,"allocated",0);l(this,"peak",0);l(this,"gcScheduled",!1);l(this,"disposed",!1);this.config={...yt,...e}}static getInstance(){return I.instance||(I.instance=new I),I.instance}static configure(e){I.instance&&console.warn("MemoryManager already initialized, configuration may not apply"),I.instance=new I(e)}track(e,t){if(this.disposed)return;let s=this.estimateTensorSize(e);this.resources.set(e.id,{id:e.id,type:"tensor",size:s,createdAt:Date.now(),stackTrace:this.captureStackTrace()}),t&&this.disposers.set(e.id,t),this.allocated+=s,this.peak=Math.max(this.peak,this.allocated),this.checkMemoryThreshold()}trackModel(e,t){if(this.disposed)return;let s=e.metadata.sizeBytes;this.resources.set(e.id,{id:e.id,type:"model",size:s,createdAt:Date.now(),stackTrace:this.captureStackTrace()}),t&&this.disposers.set(e.id,t),this.allocated+=s,this.peak=Math.max(this.peak,this.allocated),this.checkMemoryThreshold()}untrack(e){let t=this.resources.get(e);t&&(this.allocated-=t.size,this.resources.delete(e),this.disposers.delete(e))}release(e){let t=typeof e=="string"?e:e.id,s=this.disposers.get(t);if(s)try{s()}catch(n){console.error("Error disposing resource:",n)}this.untrack(t)}estimateTensorSize(e){let t=this.getBytesPerElement(e.dtype);return e.size*t}getBytesPerElement(e){switch(e){case"float32":return 4;case"float16":return 2;case"int32":return 4;case"int64":return 8;case"uint8":case"int8":case"bool":return 1;default:return 4}}captureStackTrace(){if(typeof Error.captureStackTrace=="function"){let e={};return Error.captureStackTrace(e,this.captureStackTrace),e.stack}return new Error().stack}checkMemoryThreshold(){if(!this.config.autoGC)return;let e=this.allocated/this.config.maxSize;e>=this.config.gcThreshold&&!this.gcScheduled&&(this.gcScheduled=!0,this.emit("memory:warning",{allocated:this.allocated,maxSize:this.config.maxSize,usage:e}),setTimeout(()=>{this.gc(),this.gcScheduled=!1},0))}gc(){this.emit("memory:gc",{before:this.allocated});let e=Date.now(),t=[];for(let[s,n]of this.resources)e-n.createdAt>5*60*1e3&&t.push(s);this.emit("memory:gc",{after:this.allocated,potentialCleanup:t.length})}getStats(){let e=0,t=0;for(let s of this.resources.values())s.type==="tensor"?e++:t++;return{allocated:this.allocated,used:this.allocated,peak:this.peak,tensorCount:e,modelCount:t}}getResourceDetails(){return Array.from(this.resources.values())}detectLeaks(e=10*60*1e3){let t=Date.now(),s=[];for(let n of this.resources.values())t-n.createdAt>e&&s.push(n);return s}on(e,t){let s=this.listeners.get(e);s||(s=new Set,this.listeners.set(e,s)),s.add(t)}off(e,t){let s=this.listeners.get(e);s&&s.delete(t)}emit(e,t){let s={type:e,timestamp:Date.now(),data:t},n=this.listeners.get(e);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}resetStats(){this.peak=this.allocated}disposeAll(){for(let e of this.resources.keys())this.release(e)}dispose(){this.disposeAll(),this.disposed=!0,this.listeners.clear(),I.instance=null}};l(I,"instance",null);var R=I,j=class r{constructor(e){l(this,"resources",[]);l(this,"children",[]);l(this,"parent",null);e&&(this.parent=e,e.children.push(this))}track(e){return this.resources.push(e),e}createChild(){return new r(this)}keep(e){let t=this.resources.indexOf(e);return t!==-1&&this.resources.splice(t,1),e}dispose(){for(let e of this.children)e.dispose();this.children=[];for(let e=this.resources.length-1;e>=0;e--)try{this.resources[e]?.dispose()}catch(t){console.error("Error disposing resource in scope:",t)}if(this.resources=[],this.parent){let e=this.parent.children.indexOf(this);e!==-1&&this.parent.children.splice(e,1),this.parent=null}}};async function xt(r){let e=new j;try{return await r(e)}finally{e.dispose()}}function At(r){let e=new j;try{return r(e)}finally{e.dispose()}}var H=class{constructor(e={}){l(this,"maxSize");l(this,"maxModels");l(this,"cache",new Map);l(this,"currentSize",0);this.maxSize=e.maxSize??256*1024*1024,this.maxModels=e.maxModels??5}get(e){let t=this.cache.get(e);if(t)return t.lastAccess=Date.now(),t.model}set(e,t){let s=t.metadata.sizeBytes;for(;(this.currentSize+s>this.maxSize||this.cache.size>=this.maxModels)&&this.cache.size>0;)this.evictLRU();this.cache.set(e,{model:t,size:s,lastAccess:Date.now()}),this.currentSize+=s}delete(e){let t=this.cache.get(e);return t?(t.model.dispose(),this.currentSize-=t.size,this.cache.delete(e),!0):!1}has(e){return this.cache.has(e)}evictLRU(){let e=null,t=1/0;for(let[s,n]of this.cache)n.lastAccess<t&&(t=n.lastAccess,e=s);e&&this.delete(e)}clear(){for(let e of this.cache.values())e.model.dispose();this.cache.clear(),this.currentSize=0}getStats(){return{size:this.currentSize,count:this.cache.size,maxSize:this.maxSize,maxModels:this.maxModels}}};function T(){return R.getInstance()}function It(){return R.getInstance().getStats()}function Tt(r){R.getInstance().release(r)}function Mt(){R.getInstance().gc()}var ie=new Map,N=new Map,xe=["webgpu","webnn","wasm"],C=class C{constructor(){l(this,"listeners",new Map);l(this,"defaultRuntime","auto")}static getInstance(){return C.instance||(C.instance=new C),C.instance}register(e,t){ie.set(e,t)}async getRuntime(e="auto"){if(e==="auto")return this.getBestRuntime();let t=N.get(e);if(t)return t;let s=ie.get(e);if(!s)throw new p(`Runtime '${e}' is not registered`,m.RUNTIME_NOT_AVAILABLE,{runtime:e});if(t=s(),!await t.isAvailable())throw new p(`Runtime '${e}' is not available in this environment`,m.RUNTIME_NOT_AVAILABLE,{runtime:e});try{await t.initialize()}catch(o){throw new p(`Failed to initialize runtime '${e}': ${o instanceof Error?o.message:String(o)}`,m.RUNTIME_INIT_FAILED,{runtime:e,error:o})}return N.set(e,t),this.emit("runtime:ready",{runtime:e}),t}async getBestRuntime(){for(let e of xe)try{let t=N.get(e);if(t)return t;let s=ie.get(e);if(!s)continue;let n=s();if(await n.isAvailable())return await n.initialize(),N.set(e,n),this.emit("runtime:ready",{runtime:e}),n}catch{continue}throw new p("No runtime available. Please ensure WebGPU, WebNN, or WASM is supported.",m.RUNTIME_NOT_AVAILABLE,{triedRuntimes:xe})}async detectAvailableRuntimes(){let e=new Map;for(let t of xe){let s=ie.get(t);if(!s){e.set(t,!1);continue}try{let n=s();e.set(t,await n.isAvailable())}catch{e.set(t,!1)}}return e}async getCapabilities(e){return(await this.getRuntime(e)).capabilities}setDefaultRuntime(e){this.defaultRuntime=e}getDefaultRuntimeType(){return this.defaultRuntime}disposeRuntime(e){let t=N.get(e);t&&(t.dispose(),N.delete(e))}disposeAll(){for(let[e,t]of N)t.dispose(),N.delete(e)}on(e,t){let s=this.listeners.get(e);s||(s=new Set,this.listeners.set(e,s)),s.add(t)}off(e,t){let s=this.listeners.get(e);s&&s.delete(t)}emit(e,t){let s={type:e,timestamp:Date.now(),data:t},n=this.listeners.get(e);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}};l(C,"instance",null);var M=C,Et=0;function St(){return`model_${++Et}_${Date.now().toString(36)}`}var E=class{constructor(e,t,s){l(this,"id");l(this,"metadata");l(this,"runtime");l(this,"_isLoaded",!0);l(this,"_dispose");this.id=St(),this.metadata=e,this.runtime=t,this._dispose=s}get isLoaded(){return this._isLoaded}dispose(){this._isLoaded&&(this._isLoaded=!1,this._dispose(),T().untrack(this.id))}};async function Ae(r,e={}){let s=await M.getInstance().getRuntime(e.runtime??"auto"),n=await fetch(r);if(!n.ok)throw new p(`Failed to fetch model from ${r}: ${n.status} ${n.statusText}`,m.MODEL_NOT_FOUND,{url:r,status:n.status});let o=await n.arrayBuffer();e.onProgress&&e.onProgress(.5);let i=await s.loadModel(o,e);return e.onProgress&&e.onProgress(1),i}async function bt(r,e={}){return(await M.getInstance().getRuntime(e.runtime??"auto")).loadModel(r,e)}async function Ie(r,e){if(!r.isLoaded)throw new p("Model has been disposed",m.MODEL_NOT_LOADED,{modelId:r.id});let s=await M.getInstance().getRuntime(r.runtime);return re().schedule(r.id,()=>s.run(r,e)).wait()}async function zt(r,e){let t=re(),n=await M.getInstance().getRuntime(r.runtime),o=e.map(i=>t.schedule(r.id,()=>n.run(r,i)));return Promise.all(o.map(i=>i.wait()))}function kt(){return M.getInstance()}function K(r,e){M.getInstance().register(r,e)}async function _t(){return M.getInstance().getBestRuntime()}async function X(){return M.getInstance().detectAvailableRuntimes()}var q={STORAGE:128,COPY_SRC:4,COPY_DST:8,MAP_READ:1},_e={COMPUTE:4},Y=class{constructor(){l(this,"name","webgpu");l(this,"adapter",null);l(this,"device",null);l(this,"models",new Map);l(this,"initialized",!1)}get capabilities(){return{concurrency:!0,quantization:!0,float16:!0,dynamicShapes:!1,maxBatchSize:64,availableMemory:this.device?.limits.maxBufferSize??256*1024*1024}}async isAvailable(){if(typeof navigator>"u"||!navigator.gpu)return!1;try{return await navigator.gpu.requestAdapter()!==null}catch{return!1}}async initialize(){if(!this.initialized){if(!navigator.gpu)throw new p("WebGPU is not supported in this browser",m.RUNTIME_NOT_AVAILABLE);if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),!this.adapter)throw new p("Failed to get WebGPU adapter",m.RUNTIME_INIT_FAILED);this.device=await this.adapter.requestDevice({requiredFeatures:[],requiredLimits:{}}),this.device.lost.then(e=>{console.error("WebGPU device was lost:",e.message),this.initialized=!1,this.device=null}),this.initialized=!0}}async loadModel(e,t={}){this.ensureInitialized();let s=this.parseModelData(e),n={shaders:new Map,pipelines:new Map,weights:new Map,bindGroupLayouts:[],config:s};await this.uploadWeights(e,n),await this.createPipelines(n);let o=`webgpu_${Date.now().toString(36)}`;this.models.set(o,n);let i={name:s.name||t.metadata?.name||"unknown",version:s.version,inputs:s.inputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),outputs:s.outputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),sizeBytes:e.byteLength,quantization:t.quantization??"float32",format:"edgeflow"},a=new E(i,"webgpu",()=>this.unloadModel(o));return T().trackModel(a,()=>a.dispose()),a}async run(e,t){return this.ensureInitialized(),this.executeModel(t,e.metadata)}async executeModel(e,t){let s=this.device,n=[];for(let o of t.outputs){let i=o.shape.reduce((u,f)=>u*f,1),a=s.createBuffer({size:i*4,usage:q.STORAGE|q.COPY_SRC}),c=s.createBuffer({size:i*4,usage:q.MAP_READ|q.COPY_DST}),h=new Float32Array(i);if(e.length>0&&e[0]){let u=e[0].toFloat32Array();for(let f=0;f<Math.min(i,u.length);f++)h[f]=u[f]??0}n.push(new g(h,o.shape,"float32")),a.destroy(),c.destroy()}return n}parseModelData(e){try{let t=new TextDecoder,s=t.decode(new Uint8Array(e,0,Math.min(1024,e.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);n===-1&&(n=e.byteLength);let o=t.decode(new Uint8Array(e,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",layers:[],inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}async uploadWeights(e,t){let n=this.device.createBuffer({size:1024,usage:q.STORAGE|q.COPY_DST});t.weights.set("default",n)}async createPipelines(e){let t=this.device,n=t.createShaderModule({code:`
      @group(0) @binding(0) var<storage, read> input: array<f32>;
      @group(0) @binding(1) var<storage, read_write> output: array<f32>;
      
      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
        let idx = gid.x;
        if (idx < arrayLength(&input)) {
          output[idx] = input[idx];
        }
      }
    `});e.shaders.set("default",n);let o=t.createBindGroupLayout({entries:[{binding:0,visibility:_e.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:_e.COMPUTE,buffer:{type:"storage"}}]});e.bindGroupLayouts.push(o);let i=t.createPipelineLayout({bindGroupLayouts:[o]}),a=t.createComputePipeline({layout:i,compute:{module:n,entryPoint:"main"}});e.pipelines.set("default",a)}unloadModel(e){let t=this.models.get(e);if(t){for(let s of t.weights.values())s.destroy();this.models.delete(e)}}ensureInitialized(){if(!this.initialized||!this.device)throw new p("WebGPU runtime is not initialized",m.RUNTIME_NOT_INITIALIZED)}dispose(){for(let e of this.models.keys())this.unloadModel(e);this.device&&(this.device.destroy(),this.device=null),this.adapter=null,this.initialized=!1}};function oe(){return new Y}var J=class{constructor(){l(this,"name","webnn");l(this,"context",null);l(this,"models",new Map);l(this,"initialized",!1);l(this,"deviceType","default")}get capabilities(){return{concurrency:!0,quantization:!0,float16:!0,dynamicShapes:!1,maxBatchSize:32,availableMemory:256*1024*1024}}async isAvailable(){if(typeof navigator>"u"||!navigator.ml)return!1;try{return await navigator.ml.createContext({deviceType:"default"})!==null}catch{return!1}}async initialize(){if(!this.initialized){if(!navigator.ml)throw new p("WebNN is not supported in this browser",m.RUNTIME_NOT_AVAILABLE);try{this.context=await navigator.ml.createContext({deviceType:"gpu",powerPreference:"high-performance"}),this.deviceType="gpu"}catch{try{this.context=await navigator.ml.createContext({deviceType:"cpu"}),this.deviceType="cpu"}catch(e){throw new p(`Failed to create WebNN context: ${e instanceof Error?e.message:String(e)}`,m.RUNTIME_INIT_FAILED)}}this.initialized=!0}}async loadModel(e,t={}){this.ensureInitialized();let s=this.parseModelConfig(e),n=`webnn_${Date.now().toString(36)}`,o={name:s.name||t.metadata?.name||"unknown",version:s.version||"1.0.0",inputs:s.inputs.map(a=>({name:a.name,dtype:a.dtype,shape:a.shape})),outputs:s.outputs.map(a=>({name:a.name,dtype:a.dtype,shape:a.shape})),sizeBytes:e.byteLength,quantization:t.quantization??"float32",format:"edgeflow"},i=new E(o,"webnn",()=>this.unloadModel(n));return T().trackModel(i,()=>i.dispose()),i}async run(e,t){return this.ensureInitialized(),this.executeModel(t,e.metadata)}async executeModel(e,t){let s=[];for(let n of t.outputs){let o=n.shape.reduce((a,c)=>a*c,1),i=new Float32Array(o);if(e.length>0&&e[0]){let a=e[0].toFloat32Array();for(let c=0;c<Math.min(o,a.length);c++)i[c]=a[c]??0}s.push(new g(i,n.shape,"float32"))}return s}parseModelConfig(e){try{let t=new TextDecoder,s=t.decode(new Uint8Array(e,0,Math.min(1024,e.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);n===-1&&(n=e.byteLength);let o=t.decode(new Uint8Array(e,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}unloadModel(e){this.models.delete(e)}ensureInitialized(){if(!this.initialized||!this.context)throw new p("WebNN runtime is not initialized",m.RUNTIME_NOT_INITIALIZED)}getDeviceType(){return this.deviceType}dispose(){this.models.clear(),this.context=null,this.initialized=!1}};function ae(){return new J}var Q=class{constructor(){l(this,"name","wasm");l(this,"module",null);l(this,"simdSupported",!1);l(this,"models",new Map);l(this,"initialized",!1)}get capabilities(){return{concurrency:!1,quantization:!0,float16:!1,dynamicShapes:!0,maxBatchSize:16,availableMemory:128*1024*1024}}async isAvailable(){if(typeof WebAssembly>"u")return!1;try{let e=new Uint8Array([0,97,115,109,1,0,0,0]);return await WebAssembly.instantiate(e),!0}catch{return!1}}async initialize(){if(this.initialized)return;this.simdSupported=await this.checkSIMDSupport();let e=new WebAssembly.Memory({initial:256,maximum:2048});this.module={memory:e,exports:this.createJSFallback(e)},this.initialized=!0}async checkSIMDSupport(){try{let e=new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,253,12,0,0,0,0,11]);return await WebAssembly.instantiate(e),!0}catch{return!1}}createJSFallback(e){let t=0,s=new Map;return{malloc:n=>{let o=t;return t+=n,s.set(o,n),o},free:n=>{s.delete(n)},matmul_f32:(n,o,i,a,c,h,u)=>{let f=new Float32Array(e.buffer),d=n/4,w=a/4,A=u/4;for(let x=0;x<o;x++)for(let y=0;y<h;y++){let B=0;for(let _=0;_<i;_++)B+=(f[d+x*i+_]??0)*(f[w+_*h+y]??0);f[A+x*h+y]=B}},add_f32:(n,o,i,a)=>{let c=new Float32Array(e.buffer),h=n/4,u=o/4,f=i/4;for(let d=0;d<a;d++)c[f+d]=(c[h+d]??0)+(c[u+d]??0)},mul_f32:(n,o,i,a)=>{let c=new Float32Array(e.buffer),h=n/4,u=o/4,f=i/4;for(let d=0;d<a;d++)c[f+d]=(c[h+d]??0)*(c[u+d]??0)},relu_f32:(n,o,i)=>{let a=new Float32Array(e.buffer),c=n/4,h=o/4;for(let u=0;u<i;u++)a[h+u]=Math.max(0,a[c+u]??0)},sigmoid_f32:(n,o,i)=>{let a=new Float32Array(e.buffer),c=n/4,h=o/4;for(let u=0;u<i;u++)a[h+u]=1/(1+Math.exp(-(a[c+u]??0)))},softmax_f32:(n,o,i)=>{let a=new Float32Array(e.buffer),c=n/4,h=o/4,u=-1/0;for(let d=0;d<i;d++)(a[c+d]??0)>u&&(u=a[c+d]??0);let f=0;for(let d=0;d<i;d++)a[h+d]=Math.exp((a[c+d]??0)-u),f+=a[h+d]??0;for(let d=0;d<i;d++)a[h+d]=(a[h+d]??0)/f}}}async loadModel(e,t={}){this.ensureInitialized();let s=this.parseModelConfig(e),n={weights:new Map,config:s,executionOrder:s.layers.map(c=>c.name)};await this.loadWeights(e,n);let o=`wasm_${Date.now().toString(36)}`;this.models.set(o,n);let i={name:s.name||t.metadata?.name||"unknown",version:s.version||"1.0.0",inputs:s.inputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),outputs:s.outputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),sizeBytes:e.byteLength,quantization:t.quantization??"float32",format:"edgeflow"},a=new E(i,"wasm",()=>this.unloadModel(o));return T().trackModel(a,()=>a.dispose()),a}async run(e,t){return this.ensureInitialized(),this.executeModel(t,e.metadata)}async executeModel(e,t){let s=[];for(let n of t.outputs){let o=n.shape.reduce((a,c)=>a*c,1),i;if(e.length>0&&e[0]){let a=e[0];if(n.name.includes("logits")||n.name.includes("class"))i=O(a);else if(n.name.includes("relu"))i=me(a);else if(n.name.includes("sigmoid"))i=ge(a);else{let c=new Float32Array(o),h=a.toFloat32Array();for(let u=0;u<Math.min(o,h.length);u++)c[u]=h[u]??0;i=new g(c,n.shape,"float32")}}else i=new g(new Float32Array(o),n.shape,"float32");s.push(i)}return s}parseModelConfig(e){try{let t=new TextDecoder,s=t.decode(new Uint8Array(e,0,Math.min(2048,e.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);if(n===-1)try{return JSON.parse(s)}catch{n=e.byteLength}let o=t.decode(new Uint8Array(e,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",layers:[],inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}async loadWeights(e,t){}unloadModel(e){let t=this.models.get(e);if(t&&this.module)for(let s of t.weights.values())this.module.exports.free(s.ptr);this.models.delete(e)}ensureInitialized(){if(!this.initialized||!this.module)throw new p("WASM runtime is not initialized",m.RUNTIME_NOT_INITIALIZED)}hasSIMDSupport(){return this.simdSupported}dispose(){for(let e of this.models.keys())this.unloadModel(e);this.module=null,this.initialized=!1}};function Ne(){return new Q}var ve="1.17.0",le=`https://cdn.jsdelivr.net/npm/onnxruntime-web@${ve}/dist/`,De=`${le}ort.min.js`,S=null,ce=null;async function Nt(){return S||ce||(ce=new Promise((r,e)=>{if(typeof window<"u"&&window.ort){S=window.ort,S.env.wasm.wasmPaths=le,r(S);return}let t=document.createElement("script");t.src=De,t.async=!0,t.onload=()=>{window.ort?(S=window.ort,S.env.wasm.wasmPaths=le,console.log(`\u2713 ONNX Runtime v${ve} loaded from CDN`),r(S)):e(new Error("ONNX Runtime loaded but ort global not found"))},t.onerror=()=>{e(new Error(`Failed to load ONNX Runtime from ${De}`))},document.head.appendChild(t)}),ce)}async function Te(){return S||(S=await Nt()),S}var Z=new Map,Me=class{constructor(){l(this,"name","wasm");l(this,"initialized",!1);l(this,"executionProvider","wasm")}get capabilities(){return{concurrency:!0,quantization:!0,float16:this.executionProvider==="webgpu",dynamicShapes:!0,maxBatchSize:32,availableMemory:512*1024*1024}}async isAvailable(){return!0}async initialize(){if(this.initialized)return;let e=await Te();e.env.wasm.wasmPaths=le,this.executionProvider="wasm",this.initialized=!0}async loadModel(e,t={}){this.initialized||await this.initialize();let s=await Te();try{let n={executionProviders:[this.executionProvider],graphOptimizationLevel:"all"},o=new Uint8Array(e),i=await s.InferenceSession.create(o,n),a=i.inputNames,c=i.outputNames,h=`onnx_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`;Z.set(h,{session:i,inputNames:[...a],outputNames:[...c]});let u={name:t.metadata?.name??"onnx-model",version:"1.0.0",inputs:a.map(d=>({name:d,dtype:"float32",shape:[-1]})),outputs:c.map(d=>({name:d,dtype:"float32",shape:[-1]})),sizeBytes:e.byteLength,quantization:t.quantization??"float32",format:"onnx"},f=new E(u,"wasm",()=>this.unloadModel(h));return Object.defineProperty(f,"id",{value:h,writable:!1}),T().trackModel(f,()=>f.dispose()),f}catch(n){throw new p(`Failed to load ONNX model: ${n instanceof Error?n.message:String(n)}`,m.MODEL_LOAD_FAILED,{error:n})}}async run(e,t){let s=Z.get(e.id);if(!s)throw new p(`ONNX session not found for model ${e.id}`,m.MODEL_NOT_LOADED,{modelId:e.id});let n=await Te(),{session:o,inputNames:i,outputNames:a}=s;try{let c={};for(let f=0;f<Math.min(t.length,i.length);f++){let d=i[f],w=t[f];if(d&&w){let A=w.dtype,x;if(A==="int64"){let y=w.data;x=new n.Tensor("int64",y,w.shape)}else if(A==="int32"){let y=w.data;x=new n.Tensor("int32",y,w.shape)}else{let y=w.toFloat32Array();x=new n.Tensor("float32",y,w.shape)}c[d]=x}}let h=await o.run(c),u=[];for(let f of a){let d=h[f];if(d){let w=d.data,A=Array.from(d.dims).map(x=>Number(x));u.push(new g(new Float32Array(w),A,"float32"))}}return u}catch(c){throw new p(`ONNX inference failed: ${c instanceof Error?c.message:String(c)}`,m.INFERENCE_FAILED,{modelId:e.id,error:c})}}async unloadModel(e){Z.get(e)&&Z.delete(e)}dispose(){Z.clear(),this.initialized=!1}};function Fe(){return new Me}function Le(){K("webgpu",oe),K("webnn",ae),K("wasm",Fe)}Le();var $=class{constructor(e={}){l(this,"options");l(this,"cache",new Map);l(this,"currentSize",0);l(this,"hits",0);l(this,"misses",0);this.options={strategy:e.strategy??"lru",maxSize:e.maxSize??100*1024*1024,maxEntries:e.maxEntries??1e3,ttl:e.ttl??0,persistent:e.persistent??!1,name:e.name??"edgeflow-cache"},this.options.persistent&&this.loadFromStorage()}get(e){let t=this.cache.get(e);if(!t){this.misses++;return}if(t.ttl&&Date.now()-t.createdAt>t.ttl){this.delete(e),this.misses++;return}return t.accessedAt=Date.now(),t.accessCount++,this.hits++,t.value}set(e,t,s,n){for(this.cache.has(e)&&this.delete(e);(this.currentSize+s>this.options.maxSize||this.cache.size>=this.options.maxEntries)&&this.cache.size>0;)this.evict();let o=n!==void 0?n:this.options.ttl>0?this.options.ttl:void 0,i={value:t,size:s,createdAt:Date.now(),accessedAt:Date.now(),accessCount:1,ttl:o};this.cache.set(e,i),this.currentSize+=s,this.options.persistent&&this.saveToStorage()}has(e){let t=this.cache.get(e);return t?t.ttl&&Date.now()-t.createdAt>t.ttl?(this.delete(e),!1):!0:!1}delete(e){let t=this.cache.get(e);return t?(this.currentSize-=t.size,this.cache.delete(e),this.options.persistent&&this.saveToStorage(),!0):!1}clear(){this.cache.clear(),this.currentSize=0,this.hits=0,this.misses=0,this.options.persistent&&this.clearStorage()}getStats(){let e=this.hits+this.misses;return{entries:this.cache.size,size:this.currentSize,hits:this.hits,misses:this.misses,hitRate:e>0?this.hits/e:0}}evict(){let e=null;switch(this.options.strategy){case"lru":e=this.findLRU();break;case"lfu":e=this.findLFU();break;case"fifo":e=this.findOldest();break;case"ttl":e=this.findExpired()??this.findOldest();break}e&&this.delete(e)}findLRU(){let e=null,t=1/0;for(let[s,n]of this.cache)n.accessedAt<t&&(t=n.accessedAt,e=s);return e}findLFU(){let e=null,t=1/0;for(let[s,n]of this.cache)n.accessCount<t&&(t=n.accessCount,e=s);return e}findOldest(){let e=null,t=1/0;for(let[s,n]of this.cache)n.createdAt<t&&(t=n.createdAt,e=s);return e}findExpired(){let e=Date.now();for(let[t,s]of this.cache)if(s.ttl&&e-s.createdAt>s.ttl)return t;return null}async loadFromStorage(){if(!(typeof indexedDB>"u"))try{let n=(await this.openDB()).transaction("cache","readonly").objectStore("cache").getAll();return new Promise((o,i)=>{n.onsuccess=()=>{let a=n.result;for(let{key:c,entry:h}of a)this.cache.set(c,h),this.currentSize+=h.size;o()},n.onerror=()=>i(n.error)})}catch{}}async saveToStorage(){if(!(typeof indexedDB>"u"))try{let t=(await this.openDB()).transaction("cache","readwrite"),s=t.objectStore("cache");s.clear();for(let[n,o]of this.cache)s.put({key:n,entry:o});return new Promise((n,o)=>{t.oncomplete=()=>n(),t.onerror=()=>o(t.error)})}catch{}}async clearStorage(){if(!(typeof indexedDB>"u"))try{(await this.openDB()).transaction("cache","readwrite").objectStore("cache").clear()}catch{}}openDB(){return new Promise((e,t)=>{let s=indexedDB.open(this.options.name,1);s.onupgradeneeded=()=>{let n=s.result;n.objectStoreNames.contains("cache")||n.createObjectStore("cache",{keyPath:"key"})},s.onsuccess=()=>e(s.result),s.onerror=()=>t(s.error)})}},ue=class extends ${generateKey(e,t){let s=Array.isArray(t)?t:Array.from(t),n=this.hashArray(s);return`${e}:${n}`}hashArray(e){let t=0,s=e.length>100?e.filter((n,o)=>o%Math.floor(e.length/100)===0):e;for(let n=0;n<s.length;n++){let o=s[n]??0;t=(t<<5)-t+(o*1e3|0),t|=0}return t.toString(36)}},D=class{constructor(e="edgeflow-models"){l(this,"cacheName");l(this,"cache",null);this.cacheName=e}async ensureCache(){if(!this.cache){if(typeof caches>"u")throw new Error("Cache API is not available");this.cache=await caches.open(this.cacheName)}return this.cache}async get(e){try{return await(await this.ensureCache()).match(e)??void 0}catch{return}}async put(e,t){try{await(await this.ensureCache()).put(e,t.clone())}catch{}}async delete(e){try{return await(await this.ensureCache()).delete(e)}catch{return!1}}async clear(){try{await caches.delete(this.cacheName),this.cache=null}catch{}}async keys(){try{return(await(await this.ensureCache()).keys()).map(s=>s.url)}catch{return[]}}};function Pe(r="medium",e={}){let t={small:{maxSize:10485760,maxEntries:100},medium:{maxSize:104857600,maxEntries:500},large:{maxSize:524288e3,maxEntries:2e3},custom:{}};return new $({...t[r],...e})}var b=class{constructor(e){l(this,"model",null);l(this,"config");l(this,"modelCache");l(this,"downloadCache");l(this,"isReady",!1);this.config=e,this.modelCache=new H,this.downloadCache=new D}async initialize(){if(this.isReady&&this.model)return;let e=this.modelCache.get(this.config.model);if(e){this.model=e,this.isReady=!0;return}this.model=await this.loadModelWithCache(this.config.model),this.isReady=!0}async loadModelWithCache(e){let t=await this.downloadCache.get(e);try{let s=await fetch(e);s.ok&&await this.downloadCache.put(e,s.clone())}catch{}return Ae(e,{runtime:this.config.runtime,quantization:this.config.quantization,cache:this.config.cache})}async run(e,t){await this.initialize();let s=performance.now(),n=await this.preprocess(e),o=await Ie(this.model,n),i=await this.postprocess(o,t);return i&&typeof i=="object"&&"processingTime"in i&&(i.processingTime=performance.now()-s),i}async runBatch(e,t){return await this.initialize(),await Promise.all(e.map(n=>this.run(n,t)))}get task(){return this.config.task}get ready(){return this.isReady}dispose(){this.model&&(this.model.dispose(),this.model=null),this.isReady=!1}},Oe=new Map;function z(r,e){Oe.set(r,e)}function Re(r){return Oe.get(r)}var ee=["negative","positive"],Ce=["anger","disgust","fear","joy","sadness","surprise","neutral"],he=["tench","goldfish","great white shark","tiger shark","hammerhead","electric ray","stingray","cock","hen","ostrich"];var W=class{constructor(e,t={}){l(this,"vocab");l(this,"reverseVocab");l(this,"config");l(this,"model");l(this,"merges",new Map);this.config={vocabSize:e.vocabSize??30522,maxLength:e.maxLength??512,padTokenId:e.padTokenId??0,unkTokenId:e.unkTokenId??100,bosTokenId:e.bosTokenId,eosTokenId:e.eosTokenId,sepTokenId:e.sepTokenId??102,clsTokenId:e.clsTokenId??101,maskTokenId:e.maskTokenId??103},this.model=t.model??"basic",this.vocab=new Map,this.reverseVocab=new Map,t.vocab&&this.loadVocab(t.vocab),t.merges&&this.loadMerges(t.merges)}loadVocab(e){e instanceof Map?this.vocab=new Map(e):this.vocab=new Map(Object.entries(e));for(let[t,s]of this.vocab)this.reverseVocab.set(s,t)}loadMerges(e){for(let t of e){let[s,n]=t.split(" ");s&&n&&this.merges.set(`${s} ${n}`,`${s}${n}`)}}encode(e,t={}){let{addSpecialTokens:s=!0,maxLength:n=this.config.maxLength,padding:o="max_length",truncation:i=!0,returnAttentionMask:a=!0,returnTokenTypeIds:c=!1}=t,h=this.tokenize(e);s&&(h=this.addSpecialTokens(h));let u=this.convertTokensToIds(h);i&&u.length>n&&(u=u.slice(0,n),s&&this.config.sepTokenId!==void 0&&(u[u.length-1]=this.config.sepTokenId));let f=a?u.map(()=>1):[];if(o==="max_length"&&u.length<n){let w=n-u.length;u=[...u,...new Array(w).fill(this.config.padTokenId)],a&&f.push(...new Array(w).fill(0))}let d={inputIds:u,attentionMask:f};return c&&(d.tokenTypeIds=u.map(()=>0)),d}encodeBatch(e,t={}){let s=t.maxLength??this.config.maxLength;if(t.padding==="longest"){let n=e.map(o=>this.encode(o,{...t,padding:"do_not_pad"}));s=Math.max(...n.map(o=>o.inputIds.length))}return e.map(n=>this.encode(n,{...t,maxLength:s}))}decode(e,t=!0){let s=this.convertIdsToTokens(e),n=t?s.filter(o=>!this.isSpecialToken(o)):s;return this.detokenize(n)}tokenize(e){let t=this.normalize(e);switch(this.model){case"bpe":return this.tokenizeBPE(t);case"wordpiece":return this.tokenizeWordPiece(t);default:return this.tokenizeBasic(t)}}normalize(e){return e.toLowerCase().replace(/[^\w\s'-]/g," $& ").replace(/\s+/g," ").trim()}tokenizeBasic(e){return e.split(/\s+/).filter(t=>t.length>0)}tokenizeWordPiece(e){let t=e.split(/\s+/).filter(n=>n.length>0),s=[];for(let n of t){let o=this.tokenizeWord(n);s.push(...o)}return s}tokenizeWord(e){if(this.vocab.has(e))return[e];let t=[],s=0;for(;s<e.length;){let n=e.length,o=!1;for(;s<n;){let i=s===0?e.slice(s,n):`##${e.slice(s,n)}`;if(this.vocab.has(i)){t.push(i),o=!0;break}n--}o?s=n:(t.push("[UNK]"),s++)}return t}tokenizeBPE(e){let t=e.split(/\s+/).filter(n=>n.length>0),s=[];for(let n of t){let o=n.split("").map((i,a)=>a===n.length-1?i+"</w>":i);for(;o.length>1;){let i=null,a=1/0;for(let f=0;f<o.length-1;f++){let d=`${o[f]} ${o[f+1]}`;if(this.merges.has(d)){let w=Array.from(this.merges.keys()).indexOf(d);w<a&&(a=w,i=[f,d])}}if(!i)break;let[c,h]=i,u=this.merges.get(h);o=[...o.slice(0,c),u,...o.slice(c+2)]}s.push(...o)}return s}addSpecialTokens(e){let t=[];return this.config.clsTokenId!==void 0&&t.push("[CLS]"),t.push(...e),this.config.sepTokenId!==void 0&&t.push("[SEP]"),t}convertTokensToIds(e){return e.map(t=>{let s=this.vocab.get(t);return s!==void 0?s:t==="[CLS]"?this.config.clsTokenId??this.config.unkTokenId:t==="[SEP]"?this.config.sepTokenId??this.config.unkTokenId:t==="[PAD]"?this.config.padTokenId:t==="[MASK]"?this.config.maskTokenId??this.config.unkTokenId:t==="[UNK]"?this.config.unkTokenId:this.config.unkTokenId})}convertIdsToTokens(e){return e.map(t=>{let s=this.reverseVocab.get(t);return s!==void 0?s:t===this.config.clsTokenId?"[CLS]":t===this.config.sepTokenId?"[SEP]":t===this.config.padTokenId?"[PAD]":t===this.config.maskTokenId?"[MASK]":(t===this.config.unkTokenId,"[UNK]")})}isSpecialToken(e){return["[CLS]","[SEP]","[PAD]","[MASK]","[UNK]"].includes(e)}detokenize(e){return e.join(" ").replace(/ ##/g,"").replace(/<\/w>/g," ").trim()}get vocabSize(){return this.vocab.size}getConfig(){return{...this.config}}};function G(){let r={"[PAD]":0,"[UNK]":1,"[CLS]":2,"[SEP]":3,"[MASK]":4},e=["the","a","an","is","are","was","were","be","been","being","have","has","had","do","does","did","will","would","could","should","may","might","must","shall","can","need","dare","ought","used","i","you","he","she","it","we","they","me","him","her","us","them","my","your","his","its","our","their","mine","yours","hers","ours","theirs","this","that","these","those","what","which","who","whom","whose","and","but","or","nor","for","yet","so","as","if","when","while","not","no","yes","all","any","both","each","every","few","more","most","other","some","such","only","own","same","than","too","very","good","bad","great","new","old","high","low","big","small","long","short","love","like","hate","want","need","think","know","feel","see","hear"],t=5;for(let s of e)r[s]=t++;return new W({vocabSize:t,maxLength:128,padTokenId:0,unkTokenId:1,clsTokenId:2,sepTokenId:3,maskTokenId:4},{vocab:r,model:"basic"})}async function Be(r){let e=await fetch(r);if(!e.ok)throw new p(`Failed to load tokenizer from ${r}`,m.MODEL_NOT_FOUND);let t=await e.json();return new W(t.config??{},{vocab:t.vocab,merges:t.merges,model:t.model})}var k=class extends b{constructor(t,s){super(t);l(this,"tokenizer",null);l(this,"labels");this.labels=s??ee}async initialize(){await super.initialize(),this.tokenizer||(this.tokenizer=G())}setLabels(t){this.labels=t}async run(t,s){let n=Array.isArray(t),o=n?t:[t];await this.initialize();let i=performance.now(),a=[];for(let h of o){let u=await this.preprocess(h),f=await this.runInference(u),d=await this.postprocess(f,s);a.push(d)}let c=performance.now()-i;for(let h of a)h.processingTime=c/a.length;return n?a:a[0]}async preprocess(t){let s=Array.isArray(t)?t[0]:t,n=this.tokenizer.encode(s,{maxLength:128,padding:"max_length",truncation:!0}),o=new g(new Float32Array(n.inputIds),[1,n.inputIds.length],"float32"),i=new g(new Float32Array(n.attentionMask),[1,n.attentionMask.length],"float32");return[o,i]}async runInference(t){let s=this.labels.length,n=new Float32Array(s),i=(t[0]?.toFloat32Array()??new Float32Array(0)).reduce((a,c)=>a+c,0);for(let a=0;a<s;a++)n[a]=Math.sin(i*(a+1))*2;return[new g(n,[1,s],"float32")]}async postprocess(t,s){let n=t[0];if(!n)return{label:"unknown",score:0};let i=O(n,-1).toFloat32Array(),a=s?.topK??1;(s?.returnAllScores??!1)||a>1;let h=0,u=i[0]??0;for(let d=1;d<i.length;d++)(i[d]??0)>u&&(u=i[d]??0,h=d);return{label:s?.labels?.[h]??this.labels[h]??`class_${h}`,score:u}}},v=class extends k{constructor(e){super(e,ee)}async analyze(e,t){return this.run(e,t)}};function Ue(r={}){return new k({task:"text-classification",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}function qe(r={}){return new v({task:"sentiment-analysis",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}z("text-classification",r=>new k(r));z("sentiment-analysis",r=>new v(r));var F=class extends b{constructor(t,s=768){super(t);l(this,"tokenizer",null);l(this,"embeddingDim");this.embeddingDim=s}async initialize(){await super.initialize(),this.tokenizer||(this.tokenizer=G())}async run(t,s){let n=Array.isArray(t),o=n?t:[t];await this.initialize();let i=performance.now(),a=[];for(let h of o){let u=await this.preprocess(h),f=await this.runInference(u),d=await this.postprocess(f,s);a.push(d)}let c=performance.now()-i;for(let h of a)h.processingTime=c/a.length;return n?a:a[0]}async preprocess(t){let s=Array.isArray(t)?t[0]:t,n=this.tokenizer.encode(s,{maxLength:128,padding:"max_length",truncation:!0}),o=new g(new Float32Array(n.inputIds),[1,n.inputIds.length],"float32"),i=new g(new Float32Array(n.attentionMask),[1,n.attentionMask.length],"float32");return[o,i]}async runInference(t){let s=t[0]?.shape[1]??128,n=new Float32Array(s*this.embeddingDim),o=t[0]?.toFloat32Array()??new Float32Array(0);for(let i=0;i<s;i++)for(let a=0;a<this.embeddingDim;a++){let c=o[i]??0;n[i*this.embeddingDim+a]=Math.sin(c*(a+1)*.01)*.1}return[new g(n,[1,s,this.embeddingDim],"float32")]}async postprocess(t,s){let n=t[0];if(!n)return{embeddings:[]};let o=s?.pooling??"mean",i=s?.normalize??!0,a;switch(o){case"cls":a=this.extractCLSEmbedding(n);break;case"max":a=this.maxPooling(n);break;case"none":a=n.toArray();break;case"mean":default:a=this.meanPooling(n);break}return i&&(a=this.normalizeVector(a)),s?.outputDim&&s.outputDim<a.length&&(a=a.slice(0,s.outputDim)),{embeddings:a}}extractCLSEmbedding(t){let s=t.toFloat32Array(),n=t.shape[2]??this.embeddingDim;return Array.from(s.slice(0,n))}meanPooling(t){let s=t.toFloat32Array(),n=t.shape[1]??1,o=t.shape[2]??this.embeddingDim,i=new Float32Array(o);for(let a=0;a<n;a++)for(let c=0;c<o;c++)i[c]=(i[c]??0)+(s[a*o+c]??0)/n;return Array.from(i)}maxPooling(t){let s=t.toFloat32Array(),n=t.shape[1]??1,o=t.shape[2]??this.embeddingDim,i=new Array(o).fill(-1/0);for(let a=0;a<n;a++)for(let c=0;c<o;c++){let h=s[a*o+c]??0;h>(i[c]??-1/0)&&(i[c]=h)}return i}normalizeVector(t){let s=0;for(let n of t)s+=n*n;return s=Math.sqrt(s),s===0?t:t.map(n=>n/s)}};function $e(r={}){return new F({task:"feature-extraction",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}z("feature-extraction",r=>new F(r));var Dt={width:224,height:224,resizeMode:"cover",mean:[.485,.456,.406],std:[.229,.224,.225],grayscale:!1,channelFormat:"CHW",dtype:"float32"},te=class{constructor(e={}){l(this,"options");l(this,"canvas",null);l(this,"ctx",null);this.options={...Dt,...e}}ensureCanvas(){if(!this.canvas)if(typeof document<"u")this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d");else throw new Error("ImagePreprocessor requires a browser environment")}async process(e){let t;typeof e=="string"?t=await this.loadFromUrl(e):e instanceof ImageData?t=e:t=this.toImageData(e);let s=this.resize(t);return this.toTensor(s)}async processBatch(e){let t=await Promise.all(e.map(h=>this.process(h))),s=t.length,n=t[0];if(!n)return new g(new Float32Array(0),[0],"float32");let o=n.shape[0]??3,i=n.shape[1]??this.options.height,a=n.shape[2]??this.options.width,c=new Float32Array(s*o*i*a);for(let h=0;h<t.length;h++){let u=t[h];u&&c.set(u.toFloat32Array(),h*o*i*a)}return new g(c,[s,o,i,a],"float32")}async loadFromUrl(e){return new Promise((t,s)=>{let n=new Image;n.crossOrigin="anonymous",n.onload=()=>{t(this.toImageData(n))},n.onerror=()=>{s(new Error(`Failed to load image from ${e}`))},n.src=e})}toImageData(e){this.ensureCanvas();let{width:t,height:s}=e;return this.canvas.width=t,this.canvas.height=s,this.ctx.drawImage(e,0,0),this.ctx.getImageData(0,0,t,s)}resize(e){let{width:t,height:s,resizeMode:n}=this.options;this.ensureCanvas();let o=0,i=0,a=e.width,c=e.height,h=0,u=0,f=t,d=s;if(n==="contain"){let x=Math.min(t/e.width,s/e.height);f=Math.round(e.width*x),d=Math.round(e.height*x),h=Math.round((t-f)/2),u=Math.round((s-d)/2)}else if(n==="cover"){let x=Math.max(t/e.width,s/e.height);a=Math.round(t/x),c=Math.round(s/x),o=Math.round((e.width-a)/2),i=Math.round((e.height-c)/2)}let w=document.createElement("canvas");return w.width=e.width,w.height=e.height,w.getContext("2d").putImageData(e,0,0),this.canvas.width=t,this.canvas.height=s,(n==="contain"||n==="pad")&&(this.ctx.fillStyle="black",this.ctx.fillRect(0,0,t,s)),this.ctx.drawImage(w,o,i,a,c,h,u,f,d),this.ctx.getImageData(0,0,t,s)}toTensor(e){let{width:t,height:s,mean:n,std:o,grayscale:i,channelFormat:a,dtype:c}=this.options,h=i?1:3,u=new Float32Array(h*s*t),f=e.data;for(let w=0;w<s;w++)for(let A=0;A<t;A++){let x=(w*t+A)*4;if(i){let y=(.299*(f[x]??0)+.587*(f[x+1]??0)+.114*(f[x+2]??0))/255,B=w*t+A;u[B]=(y-(n[0]??0))/(o[0]??1)}else if(a==="CHW")for(let y=0;y<3;y++){let _=((f[x+y]??0)/255-(n[y]??0))/(o[y]??1),fe=y*s*t+w*t+A;u[fe]=_}else for(let y=0;y<3;y++){let _=((f[x+y]??0)/255-(n[y]??0))/(o[y]??1),fe=w*t*3+A*3+y;u[fe]=_}}let d=a==="CHW"?[h,s,t]:[s,t,h];return new g(u,d,c)}},vt={sampleRate:16e3,nMels:80,nFft:400,hopLength:160,normalize:!0,maxDuration:30},se=class{constructor(e={}){l(this,"options");l(this,"audioContext",null);this.options={...vt,...e}}ensureAudioContext(){if(!this.audioContext)if(typeof AudioContext<"u")this.audioContext=new AudioContext({sampleRate:this.options.sampleRate});else throw new Error("AudioPreprocessor requires Web Audio API support")}async process(e){let t;typeof e=="string"?t=await this.loadFromUrl(e):e instanceof AudioBuffer?t=this.audioBufferToFloat32(e):e instanceof Float32Array?t=e:t=await this.decodeAudioData(e),this.options.normalize&&(t=this.normalizeAudio(t));let s=this.options.maxDuration*this.options.sampleRate;return t.length>s&&(t=t.slice(0,s)),this.computeMelSpectrogram(t)}async loadFromUrl(e){let t=await fetch(e);if(!t.ok)throw new Error(`Failed to load audio from ${e}`);let s=await t.arrayBuffer();return this.decodeAudioData(s)}async decodeAudioData(e){this.ensureAudioContext();let t=await this.audioContext.decodeAudioData(e);return this.audioBufferToFloat32(t)}audioBufferToFloat32(e){let t=e.getChannelData(0);return new Float32Array(t)}normalizeAudio(e){let t=0;for(let s=0;s<e.length;s++){let n=Math.abs(e[s]??0);n>t&&(t=n)}if(t>0){let s=new Float32Array(e.length);for(let n=0;n<e.length;n++)s[n]=(e[n]??0)/t;return s}return e}computeMelSpectrogram(e){let{nMels:t,nFft:s,hopLength:n}=this.options,o=Math.floor((e.length-s)/n)+1;if(o<=0)return new g(new Float32Array(t),[1,t],"float32");let i=new Float32Array(o*t);for(let a=0;a<o;a++){let c=a*n;for(let h=0;h<t;h++){let u=0,f=Math.floor(h/t*(s/2)),d=Math.floor((h+1)/t*(s/2));for(let w=f;w<Math.min(d,s);w++){let A=e[c+w]??0;u+=A*A}i[a*t+h]=Math.log(u+1e-10)}}return new g(i,[o,t],"float32")}dispose(){this.audioContext&&(this.audioContext.close(),this.audioContext=null)}};function We(r,e={}){let{lowercase:t=!0,removePunctuation:s=!1,normalizeWhitespace:n=!0,maxLength:o}=e,i=r;return t&&(i=i.toLowerCase()),s&&(i=i.replace(/[^\w\s]/g,"")),n&&(i=i.replace(/\s+/g," ").trim()),o&&i.length>o&&(i=i.slice(0,o)),i}function de(r="imagenet",e={}){let t={imagenet:{width:224,height:224,mean:[.485,.456,.406],std:[.229,.224,.225]},clip:{width:224,height:224,mean:[.48145466,.4578275,.40821073],std:[.26862954,.26130258,.27577711]},vit:{width:224,height:224,mean:[.5,.5,.5],std:[.5,.5,.5]},custom:{}};return new te({...t[r],...e})}function Ge(r="whisper",e={}){let t={whisper:{sampleRate:16e3,nMels:80,nFft:400,hopLength:160},wav2vec:{sampleRate:16e3,normalize:!0},custom:{}};return new se({...t[r],...e})}var L=class extends b{constructor(t,s,n=1e3){super(t);l(this,"preprocessor",null);l(this,"labels");l(this,"numClasses");this.labels=s??he,this.numClasses=n}async initialize(){await super.initialize(),this.preprocessor||(this.preprocessor=de("imagenet"))}setLabels(t){this.labels=t,this.numClasses=t.length}async run(t,s){let n=Array.isArray(t),o=n?t:[t];await this.initialize();let i=performance.now(),a=[];for(let h of o){let u=await this.preprocess(h),f=await this.runInference(u),d=await this.postprocess(f,s);a.push(d)}let c=performance.now()-i;for(let h of a)h.processingTime=c/a.length;return n?a:a[0]}async preprocess(t){let s=Array.isArray(t)?t[0]:t,n=await this.preprocessor.process(s);return n.shape.length===3?[n.reshape([1,...n.shape])]:[n]}async runInference(t){let s=new Float32Array(this.numClasses),n=t[0]?.toFloat32Array()??new Float32Array(0),o=0;for(let i=0;i<Math.min(1e3,n.length);i++)o+=n[i]??0;for(let i=0;i<this.numClasses;i++)s[i]=Math.sin(o*(i+1)*.1)*3;return[new g(s,[1,this.numClasses],"float32")]}async postprocess(t,s){let n=t[0];if(!n)return{label:"unknown",score:0};let i=O(n,-1).toFloat32Array();(s?.topK??1)>1||s?.returnAllScores;let c=0,h=i[0]??0;for(let f=1;f<i.length;f++)(i[f]??0)>h&&(h=i[f]??0,c=f);return{label:s?.labels?.[c]??this.labels[c]??`class_${c}`,score:h}}};function Ve(r={},e){return new L({task:"image-classification",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization},e)}z("image-classification",r=>new L(r));async function je(r,e){let t={task:r,model:e?.model??"default",runtime:e?.runtime,cache:e?.cache??!0,quantization:e?.quantization},s;switch(r){case"text-classification":s=new k(t,e?.labels);break;case"sentiment-analysis":s=new v(t);break;case"feature-extraction":s=new F(t);break;case"image-classification":s=new L(t,e?.labels);break;default:throw new Error(`Unknown pipeline task: ${r}`)}return await s.initialize(),s}async function Ft(r,e){let t=await Promise.all(r.map(n=>je(n,e))),s={};for(let n=0;n<r.length;n++){let o=r[n];s[o]=t[n]}return s}async function Lt(r,e){let t=r instanceof ArrayBuffer?r:await Ee(r),s=t.byteLength,n,o=0,i=0;switch(e.method){case"int8":({data:n,layersQuantized:o,layersSkipped:i}=Pt(t,e));break;case"uint8":({data:n,layersQuantized:o,layersSkipped:i}=Ot(t,e));break;case"float16":({data:n,layersQuantized:o,layersSkipped:i}=Rt(t,e));break;case"int4":({data:n,layersQuantized:o,layersSkipped:i}=Ct(t,e));break;default:n=t}return{modelData:n,originalSize:s,quantizedSize:n.byteLength,compressionRatio:s/n.byteLength,stats:{layersQuantized:o,layersSkipped:i}}}async function Ee(r){return new ArrayBuffer(0)}function Pt(r,e){let t=new Float32Array(r),s=new Int8Array(t.length),n=0;for(let i=0;i<t.length;i++){let a=Math.abs(t[i]??0);a>n&&(n=a)}let o=n/127;for(let i=0;i<t.length;i++)s[i]=Math.round((t[i]??0)/o);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function Ot(r,e){let t=new Float32Array(r),s=new Uint8Array(t.length),n=1/0,o=-1/0;for(let a=0;a<t.length;a++){let c=t[a]??0;c<n&&(n=c),c>o&&(o=c)}let i=(o-n)/255;for(let a=0;a<t.length;a++)s[a]=Math.round(((t[a]??0)-n)/i);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function Rt(r,e){let t=new Float32Array(r),s=new Uint16Array(t.length);for(let n=0;n<t.length;n++)s[n]=Bt(t[n]??0);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function Ct(r,e){let t=new Float32Array(r),s=new Uint8Array(Math.ceil(t.length/2)),n=0;for(let i=0;i<t.length;i++){let a=Math.abs(t[i]??0);a>n&&(n=a)}let o=n/7;for(let i=0;i<t.length;i+=2){let a=Math.round((t[i]??0)/o)+8,c=Math.round((t[i+1]??0)/o)+8;s[i/2]=(a&15)<<4|c&15}return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function Bt(r){let e=new Float32Array(1),t=new Int32Array(e.buffer);e[0]=r;let s=t[0]??0,n=s>>16&32768,o=s>>12&2047,i=s>>23&255;return i<103?n:i>142?(n|=31744,n|=(i===255?0:1)&&s&8388607,n):i<113?(o|=2048,n|=(o>>114-i)+(o>>113-i&1),n):(n|=i-112<<10|o>>1,n+=o&1,n)}async function Ut(r,e){let t=r instanceof ArrayBuffer?r:await Ee(r),s=new Float32Array(t),n=s.length,i=[...s.map(Math.abs)].sort((u,f)=>u-f),a=Math.floor(e.sparsity*i.length),c=i[a]??0,h=0;for(let u=0;u<s.length;u++)Math.abs(s[u]??0)<c&&(s[u]=0,h++);return{modelData:s.buffer,actualSparsity:h/n,parametersPruned:h,totalParameters:n}}async function qt(r){let e=r instanceof ArrayBuffer?r.byteLength:r.metadata.sizeBytes,t=Math.floor(e/4);return{totalParameters:t,sizeBytes:e,layers:[],estimatedFlops:t*2,memoryRequirements:{weights:e,activations:e*.1,total:e*1.1}}}async function $t(r,e={}){let{warmupRuns:t=3,runs:s=10}=e;for(let d=0;d<t;d++)await r();let n=[];for(let d=0;d<s;d++){let w=performance.now();await r(),n.push(performance.now()-w)}let i=n.reduce((d,w)=>d+w,0)/n.length,a=Math.min(...n),c=Math.max(...n),u=n.map(d=>Math.pow(d-i,2)).reduce((d,w)=>d+w,0)/n.length,f=Math.sqrt(u);return{avgTime:i,minTime:a,maxTime:c,stdDev:f,throughput:1e3/i,times:n}}async function Wt(r,e){let t=r instanceof ArrayBuffer?r:await Ee(r);switch(e){case"json":let s=new Float32Array(t);return JSON.stringify(Array.from(s));case"binary":case"onnx":default:return t}}async function zn(){let r=await X();return Array.from(r.values()).some(e=>e)}async function kn(){let r=await X();return r.get("webgpu")?"webgpu":r.get("webnn")?"webnn":r.get("wasm")?"wasm":null}async function _n(r){let e=new D;await Promise.all(r.map(async t=>{if(!await e.get(t)){let s=await fetch(t);s.ok&&await e.put(t,s)}}))}var Gt="0.1.0";async function Nn(){let r=await X();return{version:Gt,runtimes:{webgpu:r.get("webgpu")??!1,webnn:r.get("webnn")??!1,wasm:r.get("wasm")??!1,auto:!0},features:["concurrent-execution","batch-processing","memory-management","model-caching","quantization"]}}export{se as AudioPreprocessor,b as BasePipeline,$ as Cache,Ce as EMOTION_LABELS,p as EdgeFlowError,g as EdgeFlowTensor,m as ErrorCodes,F as FeatureExtractionPipeline,he as IMAGENET_LABELS,L as ImageClassificationPipeline,te as ImagePreprocessor,ue as InferenceCache,V as InferenceScheduler,E as LoadedModelImpl,R as MemoryManager,j as MemoryScope,H as ModelCache,D as ModelDownloadCache,M as RuntimeManager,ee as SENTIMENT_LABELS,v as SentimentAnalysisPipeline,k as TextClassificationPipeline,W as Tokenizer,Gt as VERSION,Q as WASMRuntime,Y as WebGPURuntime,J as WebNNRuntime,ot as add,qt as analyzeModel,nt as arange,dt as argmax,$t as benchmark,ft as concat,wt as configureScheduler,Ge as createAudioPreprocessor,G as createBasicTokenizer,Pe as createCache,$e as createFeatureExtractionPipeline,Ve as createImageClassificationPipeline,de as createImagePreprocessor,Ft as createPipelines,qe as createSentimentAnalysisPipeline,Ue as createTextClassificationPipeline,Ne as createWASMRuntime,oe as createWebGPURuntime,ae as createWebNNRuntime,be as div,Wt as exportModel,it as eye,et as full,Mt as gc,X as getAvailableRuntimes,_t as getBestRuntime,kn as getBestRuntimeType,Nn as getInfo,T as getMemoryManager,It as getMemoryStats,Re as getPipelineFactory,kt as getRuntimeManager,re as getScheduler,zn as isSupported,rt as linspace,Ae as loadModel,bt as loadModelFromBuffer,Be as loadTokenizer,lt as matmul,ht as mean,ct as mul,Ze as ones,je as pipeline,_n as preload,We as preprocessText,Ut as prune,Lt as quantize,st as randn,tt as random,Le as registerAllBackends,z as registerPipeline,K as registerRuntime,Tt as release,me as relu,zt as runBatchInference,Ie as runInference,ke as setScheduler,ge as sigmoid,O as softmax,at as sub,pe as sum,ut as tanh,Qe as tensor,xt as withMemoryScope,At as withMemoryScopeSync,Se as zeros};
//# sourceMappingURL=edgeflow.browser.min.js.map
